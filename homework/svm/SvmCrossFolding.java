/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package homework.svm;

import homework.Homework1;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.libsvm.core.svm_predict;
import org.libsvm.core.svm_train;

/**
 *
 * @author luca
 */
public class SvmCrossFolding {
    private List<String> dataset=new LinkedList<>();
    private List<String> acceptedFeatures=new LinkedList<>();
    private Map<Integer,List<String>> subsets=new HashMap<>(); //k subset for k-cross folding phase
    private Map<Integer,List<String>> trainsets=new HashMap<>();
    private Map<Integer,int[][]> cmatrix=new HashMap<>(); //Confusion Matrix for Malware/Secure applications evaluation
    private int kerneltype;
    
    private long starttime=System.currentTimeMillis();
    
    private Categorizer Cat=new Categorizer();
    
    private List<String> report=new LinkedList<>();//Used to print report on file
    private String testfile;
    
    private int k;

    public SvmCrossFolding(List<String> l, int k, String file,int ker) {
        testfile = file;
        report.add("Classification of dataset:" + testfile + " by SVM-Classifier (KernelType="+kerneltype+")");
        boolean skip = true;
        for (String s : l) {
            if (skip) {
                String[] fea = s.split(",");
                for (int i = 0; i < fea.length; i++) {
                    acceptedFeatures.add(fea[i]);
                }
                skip = false;
            } else {
                dataset.add(s);
            }
        }
        this.k = k;
        kerneltype=ker;
        //Memorization of Labels and features
        Cat.AddLabel("malware");
        Cat.AddLabel("secure");
    }
    
    public void stampaReport(){
        String file=System.getProperty("user.dir")+System.getProperty("file.separator")+testfile.substring(0,testfile.length()-4)+"-report-SVM-"+kerneltype+".txt";
        Homework1.StampaSuFile(report, file);
    }
    
    public void execute(){
        prepareKcrossSubsets();
        
        for(int i=1;i<=k;i++){
            executeStep(i);
        }
        
        int[][] matrix=new int[2][2];
        
        for(int y: cmatrix.keySet()){
            int[][] m=cmatrix.get(y);
            matrix[0][0]=matrix[0][0]+m[0][0];
            matrix[0][1]=matrix[0][1]+m[0][1];
            matrix[1][0]=matrix[1][0]+m[1][0];
            matrix[1][1]=matrix[1][1]+m[1][1];
        }
        
        System.out.println();
        report.add("");
        System.out.println("SVM final results:");
        report.add("SVM final results:");
        
        double precision= (((matrix[0][0])*1.0)/((matrix[0][0]+matrix[1][0])*1.0));
        double recall= ((((matrix[0][0])*1.0)/((matrix[0][0]+matrix[0][1])*1.0)));
        double falsepositiverate=  (((matrix[1][0])*1.0)/((matrix[1][0]+matrix[1][1])*1.0));
        double accuracy= (((matrix[0][0]+matrix[1][1])*1.0)/((matrix[0][0]+matrix[0][1]+matrix[1][1]+matrix[1][0])*1.0));
        double fmeasure=(((2*precision*recall)*1.0)/((precision+recall)*1.0));
        
        System.out.println();
        report.add("");
        System.out.println("Confusion Matrix:");
        report.add("Confusion Matrix:");
        report.add("   +   - ");
        System.out.println("{"+matrix[0][0]+" , "+matrix[0][1]);
        report.add("+ {"+matrix[0][0]+" , "+matrix[0][1]);
        System.out.println(matrix[1][0]+" , "+matrix[1][1]+"}");
        report.add("-  "+matrix[1][0]+" , "+matrix[1][1]+"}");
        System.out.println();
        report.add("");
        System.out.println("Precision:"+precision);
        report.add("Precision:"+precision);
        System.out.println("Recall:"+recall);
        report.add("Recall:"+recall);
        System.out.println("False positive rate:"+falsepositiverate);
        report.add("False positive rate:"+falsepositiverate);
        System.out.println("Accuracy:"+accuracy);
        report.add("Accuracy:"+accuracy);
        System.out.println("F-measure:"+fmeasure);
        report.add("F-measure:"+fmeasure);
        System.out.println(); 
        report.add("");
        report.add("Classification of dataset:"+System.getProperty("user.dir")+System.getProperty("file.separator")+testfile+" by SVM-Classifier  (KernelType="+kerneltype+")"+" completed "+Homework1.getTimeLapsed(((System.currentTimeMillis()-starttime)/1000)));
        stampaReport();       
    }
    
    public void executeStep(int i){
        long starttime=System.currentTimeMillis();
        System.out.println();
        report.add("");
        System.out.println("SVM step:"+i);
        report.add("SVM step:"+i);
        
        train(i);
        predict(i);
        
        int[][] matrix=cmatrix.get(i);
        
        double precision= (((matrix[0][0])*1.0)/((matrix[0][0]+matrix[1][0])*1.0));
        double recall= ((((matrix[0][0])*1.0)/((matrix[0][0]+matrix[0][1])*1.0)));
        double falsepositiverate=  (((matrix[1][0])*1.0)/((matrix[1][0]+matrix[1][1])*1.0));
        double accuracy= (((matrix[0][0]+matrix[1][1])*1.0)/((matrix[0][0]+matrix[0][1]+matrix[1][1]+matrix[1][0])*1.0));
        double fmeasure=(((2*precision*recall)*1.0)/((precision+recall)*1.0));
        
        System.out.println();
        report.add("");
        System.out.println("Confusion Matrix:");
        report.add("Confusion Matrix:");
        report.add("   +   - ");
        System.out.println("{"+matrix[0][0]+" , "+matrix[0][1]);
        report.add("+ {"+matrix[0][0]+" , "+matrix[0][1]);
        System.out.println(matrix[1][0]+" , "+matrix[1][1]+"}");
        report.add("-  "+matrix[1][0]+" , "+matrix[1][1]+"}");
        System.out.println();
        report.add("");
        System.out.println("Precision:"+precision);
        report.add("Precision:"+precision);
        System.out.println("Recall:"+recall);
        report.add("Recall:"+recall);
        System.out.println("False positive rate:"+falsepositiverate);
        report.add("False positive rate:"+falsepositiverate);
        System.out.println("Accuracy:"+accuracy);
        report.add("Accuracy:"+accuracy);
        System.out.println("F-measure:"+fmeasure);
        report.add("F-measure:"+fmeasure);
        System.out.println();
        report.add("");
        
        System.out.println("SVM step:"+i+" completed");
        report.add("SVM step:"+i+" completed "+Homework1.getTimeLapsed(((System.currentTimeMillis()-starttime)/1000)));
    }
    
    
    public void train(int step) {        
        List<String> dataTotrain=new LinkedList<>();        
        for(String s: trainsets.get(step)){
            dataTotrain.add(transformToSVMFormat(s));
        }
        Homework1.StampaSuFile(dataTotrain, System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step);       
        
        String[] args = {"-s","0","-t","0"+"",System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step , System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step+".model" };
        if(kerneltype==1){
           args = new String[]{"-s","0","-t","1","-c","100","-g","1","-r","1","-d","4",System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step , System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step+".model" };
        }
        if(kerneltype==2){
           args = new String[]{"-s","0","-t","2","-c","100","-g","1","-r","1","-p","0.01",System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step , System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step+".model" };
        }
        svm_train t = new svm_train();        
        try {    
            t.run(args);
        } catch (Exception e) {
        }
    }
    public void predict(int step){
        int[][] matrix=new int[2][2];
        for(String s:subsets.get(step)){
            String cat=predict(s,step);
            if(Homework1.Dictionary.contains(s)){
                if(cat.equals("malware")){//true positive
                    matrix[0][0]=matrix[0][0]+1;
                }else{//negative
                    matrix[0][1]=matrix[0][1]+1;
                }
            }else{
                if(cat.equals("secure")){//true negative
                    matrix[1][1]= matrix[1][1]+1;
                }else{
                    matrix[1][0]=matrix[1][0]+1;
                }
            }
        }
        cmatrix.put(step,matrix);
    }
    private String predict(String sha,int step) {//Returns category predicted for the passed file
        String fileout=System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+"out."+kerneltype+"."+step;
        String testFile=System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".test."+kerneltype+"."+step;
        String trainmodel=System.getProperty("user.dir")+System.getProperty("file.separator")+"svm"+System.getProperty("file.separator")+testfile+".train."+kerneltype+"."+step+".model";
        
        List<String> toTest=new LinkedList<>();
        toTest.add(transformToSVMFormat(sha));
        Homework1.StampaSuFile(toTest, testFile);
        
        try {
            String[] args = {testFile, trainmodel, fileout};
            svm_predict.main(args);
        } catch (Exception e) {}
        
        return Cat.GetLabel((int)(Double.parseDouble(Homework1.LeggiDaFile(fileout).get(0))));
    }
    
    public String transformToSVMFormat(String sha) {//Transforms a document file into a line in SVM-format style
        String out;
        List<String> data=Homework1.LeggiDaFile(Homework1.getDatasetFilewithPath(sha)); 
        
        if(Homework1.Dictionary.contains(sha)){
            out=Cat.GetLabelID("malware")+"";
        }else{
            out=Cat.GetLabelID("secure")+"";
        }
        
        String rep="";
        for (String l : data) {
                String[] split = l.split("::");
                if (acceptedFeatures.contains(split[0])) {
                    if(split[1].contains("http://") || split[1].contains("https://")) {
                        String[] inner;
                        if (split[1].contains("http://")) {
                            inner = split[1].substring("http://".length()).split("/");
                        } else {
                            inner = split[1].substring("https://".length()).split("/");
                        }
                        for(int i=0;i<inner.length;i++){
                            out = out + " " + Cat.AddCategory(inner[i]) + ":" + 1;
                        }
                    } else {
                        out = out + " " + Cat.AddCategory(split[1]) + ":" + 1;
                    }
                }
        }       


        return out;    
    }
    
    public void prepareKcrossSubsets() {       
        int L = (int)((dataset.size() * 1.0) / k);
        //System.err.println(L);
        int i = 1;
        int hi = 0;
        for (int lo = 0; lo < dataset.size(); lo = hi) {
            hi = lo + L;
            if (hi > dataset.size()) {
                hi = dataset.size();
            }
            subsets.put(i,new LinkedList<>(dataset.subList(lo, hi)));
            i++;
        }
        generateTrainandTestsets();
    }
    private void generateTrainandTestsets(){
        for(int i=1;i<=k;i++){
            List<String> test=subsets.get(i);
            List<String> train=new LinkedList<>(dataset);
            train.removeAll(test);
            trainsets.put(i, train);
        }
    }
}
