/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package homework.naivebayes;

import homework.Homework1;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 *
 * @author luca
 */
public class NaiveBayesCrossFolding {
    
    private List<String> dataset=new LinkedList<>();
    private List<String> acceptedFeatures=new LinkedList<>();
    private Map<Integer,List<String>> subsets=new HashMap<>(); //k subset for k-cross folding phase
    private Map<Integer,List<String>> trainsets=new HashMap<>();
    private Map<Integer,MultinomialClassifier> classifiers=new HashMap<>();
    private Map<Integer,int[][]> cmatrix=new HashMap<>(); //Confusion Matrix for Malware/Secure applications evaluation 
    
    private Map<String,Document> cleanDocuments=new HashMap<>();//used only to make less computations
    private List<String> report=new LinkedList<>();//Used to print report on file
    private String testfile;
    
    private long starttime=System.currentTimeMillis();
    
    private int k;
    private int globalID=0;
    
    public NaiveBayesCrossFolding(List<String> l,int k,String file){
        testfile=file;
        report.add("Classification of dataset:"+System.getProperty("user.dir")+System.getProperty("file.separator")+testfile+" by Naive-Bayes-Classifier");
        boolean skip=true;
        for(String s:l){
            if(skip){
                String[] fea=s.split(",");
                for(int i=0;i<fea.length;i++){
                    acceptedFeatures.add(fea[i]);
                }
                skip=false;
            }else{
                dataset.add(s);
            }
        }
        this.k=k;
    }
    
    public void stampaReport(){
        String file=System.getProperty("user.dir")+System.getProperty("file.separator")+testfile.substring(0,testfile.length()-4)+"-report-BayesMultinomial.txt";
        Homework1.StampaSuFile(report, file);
    }
    
    public void execute(){
        prepareKcrossSubsets();
        
        for(int i=1;i<=k;i++){
            executeStep(i);
        }
        
        int[][] matrix=new int[2][2];
        
        for(int y: cmatrix.keySet()){
            int[][] m=cmatrix.get(y);
            matrix[0][0]=matrix[0][0]+m[0][0];
            matrix[0][1]=matrix[0][1]+m[0][1];
            matrix[1][0]=matrix[1][0]+m[1][0];
            matrix[1][1]=matrix[1][1]+m[1][1];
        }
        
        System.out.println();
        report.add("");
        System.out.println("Naive-Bayes-Classifier final results:");
        report.add("Naive-Bayes-Classifier final results:");
        
        double precision= (((matrix[0][0])*1.0)/((matrix[0][0]+matrix[1][0])*1.0));
        double recall= ((((matrix[0][0])*1.0)/((matrix[0][0]+matrix[0][1])*1.0)));
        double falsepositiverate=  (((matrix[1][0])*1.0)/((matrix[1][0]+matrix[1][1])*1.0));
        double accuracy= (((matrix[0][0]+matrix[1][1])*1.0)/((matrix[0][0]+matrix[0][1]+matrix[1][1]+matrix[1][0])*1.0));
        double fmeasure=(((2*precision*recall)*1.0)/((precision+recall)*1.0));
        
        System.out.println();
        report.add("");
        System.out.println("Confusion Matrix:");
        report.add("Confusion Matrix:");
        report.add("   +   - ");
        System.out.println("{"+matrix[0][0]+" , "+matrix[0][1]);
        report.add("+ {"+matrix[0][0]+" , "+matrix[0][1]);
        System.out.println(matrix[1][0]+" , "+matrix[1][1]+"}");
        report.add("-  "+matrix[1][0]+" , "+matrix[1][1]+"}");
        System.out.println();
        report.add("");
        System.out.println("Precision:"+precision);
        report.add("Precision:"+precision);
        System.out.println("Recall:"+recall);
        report.add("Recall:"+recall);
        System.out.println("False positive rate:"+falsepositiverate);
        report.add("False positive rate:"+falsepositiverate);
        System.out.println("Accuracy:"+accuracy);
        report.add("Accuracy:"+accuracy);
        System.out.println("F-measure:"+fmeasure);
        report.add("F-measure:"+fmeasure);
        System.out.println(); 
        report.add("");
        report.add("Classification of dataset:"+System.getProperty("user.dir")+System.getProperty("file.separator")+testfile+" by Naive-Bayes-Classifier completed "+Homework1.getTimeLapsed(((System.currentTimeMillis()-starttime)/1000)));
        stampaReport();       
    }
    
    public void executeStep(int i){
        long starttime=System.currentTimeMillis();
       
        System.out.println();
        report.add("");
        System.out.println("Naive-Bayes-Classifier step:"+i);
        report.add("Naive-Bayes-Classifier step:"+i);
        trainData(i);
        testData(i);
        
        int[][] matrix=cmatrix.get(i);
        
        double precision= (((matrix[0][0])*1.0)/((matrix[0][0]+matrix[1][0])*1.0));
        double recall= ((((matrix[0][0])*1.0)/((matrix[0][0]+matrix[0][1])*1.0)));
        double falsepositiverate=  (((matrix[1][0])*1.0)/((matrix[1][0]+matrix[1][1])*1.0));
        double accuracy= (((matrix[0][0]+matrix[1][1])*1.0)/((matrix[0][0]+matrix[0][1]+matrix[1][1]+matrix[1][0])*1.0));
        double fmeasure=(((2*precision*recall)*1.0)/((precision+recall)*1.0));
        
        System.out.println();
        report.add("");
        System.out.println("Confusion Matrix:");
        report.add("Confusion Matrix:");
        report.add("   +   - ");
        System.out.println("{"+matrix[0][0]+" , "+matrix[0][1]);
        report.add("+ {"+matrix[0][0]+" , "+matrix[0][1]);
        System.out.println(matrix[1][0]+" , "+matrix[1][1]+"}");
        report.add("-  "+matrix[1][0]+" , "+matrix[1][1]+"}");
        System.out.println();
        report.add("");
        System.out.println("Precision:"+precision);
        report.add("Precision:"+precision);
        System.out.println("Recall:"+recall);
        report.add("Recall:"+recall);
        System.out.println("False positive rate:"+falsepositiverate);
        report.add("False positive rate:"+falsepositiverate);
        System.out.println("Accuracy:"+accuracy);
        report.add("Accuracy:"+accuracy);
        System.out.println("F-measure:"+fmeasure);
        report.add("F-measure:"+fmeasure);
        System.out.println();
        report.add("");
        
        System.out.println("Naive-Bayes-Classifier step:"+i+" completed");
        report.add("Naive-Bayes-Classifier step:"+i+" completed "+Homework1.getTimeLapsed(((System.currentTimeMillis()-starttime)/1000))); 
    }
    
    public void testData(int step){
        int[][] matrix=new int[2][2];//0 means positive, 1 means negative
        MultinomialClassifier Cl=classifiers.get(step);
        List<String> testset=subsets.get(step);
        Map<String,Document> documents=new HashMap<>();
        Map<String,Double> probabilities=new HashMap<>();
        
        String[] V=Cl.words.keySet().toArray(new String[]{}); //All words in the Training set       
        String[] C=Cl.category_Document.keySet().toArray(new String[]{}); //All categories defined
        
        //Calculation of prior probabilities for Multinomial
        for(int j=0;j<C.length;j++){              
            int tj=Cl.getDocCount(C[j]);             
            double Pcj=(tj*1.0)/(Cl.getDocCount()*1.0);
            probabilities.put(C[j], Pcj);
            int TFj=Cl.getNoOfWords(C[j]);
            for(int i=0;i<V.length;i++){
                if(!V[i].equals("")){
                    int TFij=Cl.getNoOfWords(C[j], V[i]);
                    double num=(TFij+1)*1.0;
                    double den=(TFj+V.length)*1.0;
                    double Pwicj=num/den;
                    probabilities.put(V[i]+C[j], Pwicj);
                }
            }
        }
       
        for(String s:testset){
            String document = "";
            Document D=cleanDocuments.get(s);
            if (D == null) {
                for (String l : Homework1.LeggiDaFile(Homework1.getDatasetFilewithPath(s))) {

                    String[] tot = l.split("::");
                    String found = tot[1];
                    if (acceptedFeatures.contains(tot[0])) {
                        if (document.equals("")) {
                            document = found;
                        } else {
                            document = document + " " + found;
                        }
                    }

                }
                D = new Document(globalID++, document);
                cleanDocuments.put(s, D);
            }
            //Now i define all words of D that exists in V
            List<String> words = new LinkedList<>();
            List<String> V1 = new LinkedList<>(Cl.words.keySet());
            for (int j = 0; j < D.listOfWords.length; j++) {
                String l = D.listOfWords[j];
                if (V1.contains(l)) {
                    words.add(l);
                }
            }

            String Category = "";
            double maxProb = 0;
            for (int j = 0; j < C.length; j++) {
                double ProdProb = Math.log(probabilities.get(C[j])); //Use of a logaritmic normalization to get a better result (from product to sum)
                for (String wi : words) {
                    if (!wi.equals("")) {
                        ProdProb += Math.log(probabilities.get(wi + C[j]));//Use a logaritmic normalization to get a better result (from product to sum)   
                    }
                }
                
                if (ProdProb > maxProb || maxProb == 0) {
                    maxProb = ProdProb;
                    Category = C[j];
                }
            }
            D.setCategory(Category);
            
            documents.put(s, D);
        }
        
        for(String s: documents.keySet()){
            if(Homework1.Dictionary.contains(s)){
                if(documents.get(s).getCategory().equals("malware")){//true positive
                    matrix[0][0]=matrix[0][0]+1;
                }else{//negative
                    matrix[0][1]=matrix[0][1]+1;
                }
            }else{
                if(documents.get(s).getCategory().equals("secure")){//true negative
                    matrix[1][1]= matrix[1][1]+1;
                }else{
                    matrix[1][0]=matrix[1][0]+1;
                }
            }
        }
        
        cmatrix.put(step, matrix);
    }
    
    public void trainData(int step){ //Creates, for the specified step, an Object that classifies the text of each Document in the correspondent trainset 
        MultinomialClassifier C=new MultinomialClassifier();
        List<String> trainset=trainsets.get(step);
        for(String s:trainset){
            String document="";
            Document D=cleanDocuments.get(s);
            if (D == null) {
                for (String l : Homework1.LeggiDaFile(Homework1.getDatasetFilewithPath(s))) {
                      try {
                        String[] tot = l.split("::");
                        String found = tot[1];
                        if (acceptedFeatures.contains(tot[0])) {
                            if (document.equals("")) {
                                document = found;
                            } else {
                                document = document + " " + found;
                            }
                        }
                    } catch (Exception e) {}
                }
                D = new Document(globalID++, document);
                cleanDocuments.put(s, D);
            }
            D.setCategory("secure");
            if(Homework1.Dictionary.contains(s)){
                D.setCategory("malware");
            }
            C.Add(D);
        }
        classifiers.put(step, C);     
    }
    
    public void prepareKcrossSubsets() {
        int L = (int)((dataset.size() * 1.0) / k); 
        int i = 1;
        int hi = 0;
        for (int lo = 0; lo < dataset.size(); lo = hi) {
            hi = lo + L;
            if (hi > dataset.size()) {
                hi = dataset.size();
            }
            subsets.put(i,new LinkedList<>(dataset.subList(lo, hi)));
            i++;
        }
        generateTrainandTestsets();
    }
    private void generateTrainandTestsets(){
        for(int i=1;i<=k;i++){
            List<String> test=subsets.get(i);
            List<String> train=new LinkedList<>(dataset);
            train.removeAll(test);
            trainsets.put(i, train);
        }
    }
}
